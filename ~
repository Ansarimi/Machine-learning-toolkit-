from pymongo import Connection
import os,sys,urllib2
import time
import json
import logging
from fuzzywuzzy import fuzz
import hashlib
import logging
from cosme.pipes.utils import utils
from nltk import regexp_tokenize, tokenwrap, word_tokenize
import re
import string
logging.basicConfig(filename='matchLog.log', level=logging.DEBUG)


INDB = 'production'
INCOLL = 'lalina1018'	
OUTDB = 'matching'
OUTCOLL = 'la1018'

TESTDB = 'matching'
TESTCOLL = 'unittest'

class FieldMapReduce(object):
	def __init__(self):
		self.connection = Connection()

		self.indb = self.connection[INDB]
		self.indb = self.indb[INCOLL]

		outdb = Connection()
		outdb = outdb[OUTDB]
		self.outdb = outdb[OUTCOLL]
		self.mem = []

		testdb = Connection()
		testdb = testdb[TESTDB]
		self.testdb = testdb[TESTCOLL]
		self.catTable = self.buildCategoryTable(self.indb, 'category.list')


	#THIS FUNCTION OUTPUTS ALL *UNIQUE FIELDS INTO A FILE. SUCH AS ALL UNQIUE BRANDS TO A SINGLE FILE.	
	def fieldMapToFile(self, stringfield, collection):
		savedoc = open(stringfield+'map', 'wb')
		temp = []
		for item in collection.find():
			if not any(item[stringfield] in s for s in temp):
				temp.append(item[stringfield])
		temp = sorted(temp)
		for a in temp:
			savedoc.write("%s\n" % a.encode('utf-8'))		
		savedoc.close()
	
	def fieldMapToArray(self, stringfield, collection):
		temp = []
		for item in collection.find():
			if not any(item[stringfield] in s for s in temp):
				temp.append(item[stringfield])
		return temp
	#LookUP file specs:
	#file must be coma seperated with parent brand or category as the first element
	#example: if we want the following to be reduced to 'perfumes'
	#a line in the file for the category would look like:
	# perfumes,perfumaria,perfume,feminino

	def buildCategoryTable(self, collection, lookupfile):
		catlist = open(lookupfile)
		masterList = []
		for item in catlist.readlines():
			item = item.split(',')
			arr = []
			for a in item:
				a = a.decode('utf8')
				a = a.rstrip()
				arr.append(a)
			mydic = { arr[0] : arr[1:]}
			masterList.append(mydic)
	
		return masterList
	#field reduce method looks up a field in the value (array) then the key (string) in a list of dictionaries to mapreduce categories 
	def fieldReduce(self, fieldValue):
		out = ''
		fieldValue = fieldValue.decode('utf8')
		for item in self.catTable:
			print item
			print fieldValue
			for key, value in item.iteritems():
				arr = value
				if fieldValue == key:
					print 'key Match %s ' % fieldValue
					return key
				elif any(fieldValue in s for s in arr):
					print 'fieldmatch %s ' % fieldValue
					out = key
					return out
						

	def fieldReduceCheckValue(self, fieldValue):
		out = ''
		for item in self.catTable:
			for key,value in item.iteritems():
				arr = value
				if any(fieldValue in s for s in arr):
					return key, value
				
	
	def negativeCheck(self, name, category):
		
		name = name.decode('utf8')
		name = name.split()
		for item in name:
			negValue = self.fieldReduce(item)
			catKey, value = self.fieldReduceCheckValue(negValue)
			if negValue == item:
				print 'nothing found'
				#found nothing
			elif negValue == category:
				#all is good move alongi
				print 'category confirmed by name'
			elif negValue == value:
				if category == key:
					print 'name confirms category'	
					#all is good means the negValue lookup from name contains a synoym from the table and that the category is equal to the root of the synonym
				else:
					print 'name conflict with category for word %s ' % value	
				
			#if neg value is equal to another element 
				
					


	def name2fieldSearch(self, name):
		name = name.decode('utf8')
		


class Mapreduce(object):

	def __init__(self):
		self.pattern = r'(?x)\n  ([A-Z]\\.)+  \n | \\w+(-\\w+)*\n| \\$?\\d+(\\.\\d+)?%?\n| \\.\\.\\.\n| [][.,;"\'?():-_`]\n'
		# this cleans all punction
		self.volPattern = r'''(?i) \d+ml|\d+ ml|\d+ML|\d+ML|\d+g|\d+ g|\d+gr|\d+ gramas|\d+ gr|\d+gramas'''
		#converts voluem types to generic types
		self.connection = Connection()

		self.indb = self.connection[INDB]
		self.indb = self.indb[INCOLL]

		outdb = Connection()
		outdb = outdb[OUTDB]
		self.outdb = outdb[OUTCOLL]
		self.mem = []

		testdb = Connection()
		testdb = testdb[TESTDB]
		self.testdb = testdb[TESTCOLL]
		print self.indb
		self.fieldMapReduce = FieldMapReduce()	

	def makeMappingCopy(self):
		for item in self.indb.find():
			if 'name' in item:
				#try:
					copyObject = item 
					self.lowerfields(copyObject) 
					newName = self.cleaner(copyObject['name'])
					newVolume = self.remVolWhiteSpace(copyObject['volume'])
					newBrand = self.punctuationStripper(copyObject['brand'])
					newCategory = copyObject['category']
						
					copyObject['category'] = self.fieldMapReduce.fieldReduce(newCategory)
					copyObject['brand'] = newBrand
					copyObject['price_str'] = self.floatPriceToString(item['price'])		
					copyObject['volume'] = self.fieldScrubber(item, 'volume')
					copyObject['name'] = newName
					copyObject['key'] = item['key']
					#copyObject['groupid'] = self.dummyGroupKey(item)
					self.updateInDb(copyObject)	
					#self.mem.append(copyObject)
			#	except Exception, e:
			#		print e
			#		self.mem.append((item['key'],e))
					
			#		print item['key']	
		#self.updateInDb(self.mem.append)
		print ' error : %s ' % len(self.mem)
		print 'coppied %s' % self.outdb.count()
		self.writeToFile(self.mem)

	def stampDummyKey(self):
	#this is needed for solr to group things by groupid.
		counter = 0 
		toPatch = self.outdb.find({ 'groupid': { '$exists': 0}}).count()
		for item in self.outdb.find({ 'groupid': { '$exists': 0}}):
			if not 'groupid' in item:
				item['groupid'] =self.dummyGroupKey(item)
				self.updateMongo(item, self.outdb)				
				counter = counter+ 1
		print 'items patched: %s ' % counter
		print 'items needed patching %s ' %toPatch
 		
	def cleanVolume(self, name):
		replaceList = regexp_tokenize(name, self.volPattern)
		crop = name
		if len(replaceList) > 0:
			for val in replaceList:
				crop = crop.replace(val, "")	
			crop = crop.strip()
			return crop
		else:
			return crop

	def removeMidWhiteSpaces(self, name):
		name = re.sub(r'\s+', ' ', name)
		return name	
	
	def punctuationStripper(self, string):
		phrase = string.strip()
		phrase = phrase.split(' ')
		out = []
		for item in phrase:
			a = ''.join(e for e in item if e.isalnum())
			out.append(a)
		out = ' '.join(out)
		return out

	def cleanName(self, name):
		exclude = set(string.punctuation)
		out = ''.join(ch for ch in name if ch not in exclude)				
		
		return out

	def quickExpand(self, name):
		r = r'edt|edp|c/|p/|eau de parfum|homme'
		expanddict = { 'p/':'para','c/':'com','edt' : 'eau de toilette', 'edp': 'eau de perfume','eau de parfum':'eau de perfume','homme':'masculino' }
		a = re.search(r, name)
		if a is not None:
			a = a.group()
			for keys in expanddict:
				if keys == a:
					name = name.replace(a, expanddict[keys])
					return name
		else:
			return name
			
	def dupRemove(self, a):	
		a = ' '.join(self.unique_list(a.split()))
		return a

	def unique_list(self, l):
		ulist = []
    		[ulist.append(x) for x in l if x not in ulist]
    		return ulist 
		
	def remVolWhiteSpace(self, vol):
		vol = "".join(vol.split())
		vol = vol.lower()
		return vol
	
	def fieldScrubber(self, item, fieldToClean):
		if item[fieldToClean] is None:
			return 'NA'
			print 'was None %s' % item['key']
		if item[fieldToClean] == '':
			return 'NA'
		elif len(item[fieldToClean]) == 0:
			return 'NA'
		elif item[fieldToClean] == ['NA']:
			return 'NA'

	def cleaner(self, newName):
		newName = newName.encode('utf8')
		newName = newName.lower()
		newName = self.quickExpand(newName)	
		newName = self.cleanVolume(newName)
		newName = self.cleanName(newName)
		newName = self.dupRemove(newName)
		newName = self.removeMidWhiteSpaces(newName)
		return newName

	def floatPriceToString(self, priceFloat):
		if isinstance(priceFloat, list):
			priceFloat = priceFloat[0]
			pricestr = '%.2f' % priceFloat 
			return pricestr
		else:
			pricestr = '%.2f' % priceFloat 
			return pricestr
			
	def dummyGroupKey(self, item):
		if not 'groupid' in item:
			groupid = '0000' + item['key']
			return groupid
		else:
			return item['groupid']

	def patchDeadArrayToString(self, field):
		if isinstance(field, list) and not field:
			fix = ''
			print 'patch done %s ' % field
			return fix
		else:
			return field
	
	def arrayToString(self, field):
		if isinstance(field, list) and field:
			print 'array element grab %s ' %field
			out = field[0]
			return out
		else:
			return field
	def arrayFixer(self, field):
		print 'fixer ran'
		field = self.patchDeadArrayToString(field)
		field = self.arrayToString(field)
		return field

	def lowerfields(self, item):
		l = ['product_id','matchscore','image','comments','price','date_crawled','_id', 'matchscore', 'rank', 'sku']
		uniq = set(l)
		for key, value in item.items():
			if not key in uniq:
					if isinstance(value, list):
						item[key] = self.arrayFixer(value)	
						print item[key]
					if value is not None:
						item[key] = item[key].lower().strip()
					else:
						print item[key]
						print key
						print '$$$$$$$$$$$$$$$ VALUE WAS NONE $$$$$$$$$$$$ %s' % item['key'] 
						value = ''
	def addStringPrice(self):
		for item in self.indb.find():
			try:
				copyObject = item 
				copyObject['price_str'] = self.floatPriceToString(item['price'])		
				self.updateInDb(copyObject)	
			except Exception, e:
				print e
				self.mem.append(item['key'])
				
				print item['key']	

	def writeToFile(self, temp):
		savedoc = open('errorlogmap', 'wb')
		for a in temp:
			savedoc.write("%s\n" % a[0].encode('utf-8'), a[1].encode('utf-8'))		
		savedoc.close()
	
	def updateMongo(self, item, db):
		try:
			db.update({'key':item['key']}, {'$set': { 'groupid': item['groupid'] } }, upsert = True) 
		
		except Exception, e:
			print 'mongo exception'
			
	def updateInDb(self, item):
		try:
			self.outdb.insert(item, safe=True)
		
		except Exception, e:
			print 'mongo exception'

		
	def main(collection):
		connection = Connection()
		db = connection[OUTDB]
		db = db[collection]
		print 'collection in use %s' %db

class FieldOps(Mapreduce):
	
	def addfield(self):
		print 'hello'		
#if __name__ == "__main__":

    #first argument: batch size
    #second argument: dmp or feed
    #third argument : filename
    
